
# Capítulo 5

# Filter
```{r}
library(nycflights13)
library(tidyverse)

(jan1 <- filter(flights, month == 1, day == 1))

(nov_dec <- filter(flights, month %in% c(11, 12)))


# testing logical operations
sqrt(2) ^ 2 == 2
near(sqrt(2) ^ 2,  2)
```

```{r}
# 5.2.4 Exercícios

# 1)
e1 <- filter(flights, arr_delay > 2)
e2 <- filter(flights, dest %in% c('HOU','IAH'))
e3 <- filter(flights, carrier %in% c('UA','AA','DL'))
e4 <- filter(flights, month %in% c(7,8,9))
e5 <- filter(flights, arr_delay > 2 & dep_delay <= 0)
# esse aqui tá errado, tenho que pensar melhor
# Were delayed by at least an hour, but made up over 30 minutes in flight
e6 <- filter(flights, dep_delay + arr_delay >= 60 & air_time - abs((sched_dep_time - arr_time)) <= 30 )
e7 <- filter(flights, dep_time >= 0 & dep_time <= 600)

# 2)
e7 <- filter(flights, between(dep_time, 0, 600))  
  
# 3)
nrow(filter(flights, is.na(dep_time)))
```

# Arrange

```{r}
arrange(flights, year, month, day)
arrange(flights, desc(dep_delay))
df <- tibble(x = c(5, 2, NA))
arrange(df, x)
arrange(df, desc(x))

```

```{r}

# 5.3.1 Exercícios

# 1)
df <- tibble(x = c(5, 2, NA))
arrange(df, desc(is.na(x)))

# 2)
df_2 <- tibble(delays = flights$dep_delay + flights$arr_delay)
arrange(df_2, desc(delays))
arrange(df_2, delays)

# Sort flights to find the fastest (highest speed) flights.
# 3)
df_3 <- tibble(speed = abs(flights$arr_time - flights$dep_time))
arrange(df_3, speed)

# 4)
df_4 <- tibble(dist = flights$distance)
arrange(df_4, desc(dist))
arrange(df_4, dist)

```
# Select

```{r}
select(flights, year, month, day)
select(flights, year:day)
select(flights, -(year:day))
```
```{r}
# 5.4.1 Exercises

# Brainstorm as many ways as possible to select dep_time, dep_delay, arr_time, and arr_delay

# 1,2)
select(flights, dep_time, dep_delay, arr_time, arr_delay)
select(flights, starts_with('dep'))
select(flights, dep_time, dep_delay, arr_time, arr_delay, dep_time)

# 3)
vars <- c("year", "month", "day", "campo_inexistente")

# a função one_of() avalia e avisa se algum campo não existe.
# sem usar essa função, só passando a string, pode ser que não exista um campo e um erro é retornado
select(flights, one_of((vars)))
# select(flights, vars)
select(flights, contains("TIME"))
```
# Mutate

```{r}
flights_sml <- select(flights, 
  year:day, 
  ends_with("delay"), 
  distance, 
  air_time
)
mutate(flights_sml,
  gain = dep_delay - arr_delay,
  speed = distance / air_time * 60
)


transmute(flights_sml,
  gain = dep_delay - arr_delay,
  hours = air_time / 60,
  gain_per_hour = gain / hours
)


transmute(flights,
  dep_time,
  hour = dep_time %/% 100,
  minute = dep_time %% 100
)
```

## Useful creation functions

### lag and lead
```{r}
(x <- 1:10)
lag(x, 1)
lead(x, 2)

x <- runif(5)
cbind(ahead = lead(x), x, behind = lag(x))

df <- data.frame(year = 2000:2005, value = (0:5) ^ 2)
scrambled <- df[sample(nrow(df)), ]

wrong <- mutate(scrambled, prev = lag(value))
arrange(wrong, year)

right <- mutate(scrambled, prev = lag(value, order_by = year))
arrange(right, year)

# ---------------------------------------------------------
```

```{r}
(x <- 1:10)
cumsum(x)
cummean(x)

y <- c(1, 2, 2, NA, 3, 4)
min_rank(y)
min_rank(desc(y))

row_number(y)
dense_rank(y)

percent_rank(y)
cume_dist(y)
```
## Na moral, parte mais difícil do capítulo

O exercício sempre dá uma diferença de algumas horas e não entendi bem porquê.

Minha lógica foi dividir o tempo em hora e minuto e depois converter hora pra minutos e somar as duas colunas. Se o tempo de um dia inteiro menos o tempo de partida fosse maior que o tempo total de chegada, quer dizer que o voo foi de um dia para o outro(passou de meia noite). 

Então fiz desse jeito:

```
i := tempo de partida
k := tempo de chegada


se $24*60 - i > k$:
  tempo_total := 24*60 - partida + chegada
  
caso contrário:
  tempo_total := chegada - partida
```
  
Mas isso deu errado, não sei se por detalhe no código ou se minha definição está errada mesmo.
  
```{r}
# 5.5.2 Exercícios

# 1)
dia_inteiro = 1440
dep_time_df <- select(flights, dep_time)
mutate(dep_time_df, hours = dep_time %/% 100 , minutes = dep_time %% 100)

# 2)
real_time <- select(flights, air_time, arr_time, dep_time)
(real_time2 <- mutate(real_time, arr_hour = ((arr_time%/%100)*60), arr_min = (arr_time%%100), dep_hour = ((dep_time%/%100)*60), dep_min = (dep_time%%100)))

(real_time3 <-  mutate(real_time2, est_time= ifelse(dia_inteiro - (dep_hour + dep_min) > arr_hour + arr_min, dia_inteiro + (arr_hour + arr_min) - (dep_min + dep_hour), (arr_hour + arr_min) - (dep_min + dep_hour))))

arrange(real_time3, est_time)

# 3)
select(flights, dep_time, sched_dep_time, dep_delay)
# dep_delay = dep_time - sched_dep_time


```

```{r}
# 4)

# Find the 10 most delayed flights using a ranking function. How do you want to handle ties? Carefully read the documentation for min_rank().

f2 <- transmute(flights, delays = dep_delay + arr_delay)
arrange(f2, min_rank(desc(delays)))

# 5) 
# 1:3 + 1:10
# 6) 
?Trig
```

# Summarise
```{r}

summarise(flights, delay = mean(dep_delay, na.rm = TRUE))
by_day <- group_by(flights, year, month, day)
summarise(by_day, delay = mean(dep_delay, na.rm = TRUE))

```

```{r}
by_dest <- group_by(flights, dest)
delay <- summarise(by_dest,
  count = n(),
  dist = mean(distance, na.rm = TRUE),
  delay = mean(arr_delay, na.rm = TRUE)
)
delay <- filter(delay, count > 20, dest != "HNL")

# It looks like delays increase with distance up to ~750 miles 
# and then decrease. Maybe as flights get longer there's more 
# ability to make up delays in the air?
ggplot(data = delay, mapping = aes(x = dist, y = delay)) +
  geom_point(aes(size = count), alpha = 1/3) +
  geom_smooth(se = FALSE)
#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'


```

```{r}
delays <- flights %>% 
  group_by(dest) %>% 
  summarise(
    count = n(),
    dist = mean(distance, na.rm = TRUE),
    delay = mean(arr_delay, na.rm = TRUE)
  ) %>% 
  filter(count > 20, dest != "HNL")

delays
```

```{r}
```

```{r}
```

```{r}
```